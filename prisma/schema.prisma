// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ====================================
// Enums - Converted to dynamic dropdown options (String fields)
// Values are now managed through the DropdownOption table
// ====================================

enum TestLayer {
  SMOKE
  CORE
  EXTENDED
  UNKNOWN
}

// ====================================
// User Management
// ====================================
model User {
  id            String    @id @default(cuid())
  email         String    @unique
  name          String
  password      String
  roleId        String    // FK to Role table
  avatar        String?
  bio           String?
  phone         String?
  location      String?
  deletedAt     DateTime? // Soft delete timestamp (null = active, has value = archived for deletion)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  role          Role      @relation(fields: [roleId], references: [id])
  projects      ProjectMember[]
  testCases     TestCase[]
  assignedTestRuns TestRun[]
  createdTestRuns TestRun[] @relation("TestRunCreator")
  testResults   TestResult[]
  comments      Comment[]
  createdProjects Project[] @relation("CreatedBy")
  passwordResetTokens PasswordResetToken[]
  apiKeys        ApiKey[]
  assignedDefects Defect[] @relation("DefectAssignedTo")
  createdDefects  Defect[] @relation("DefectCreatedBy")
  defectComments  DefectComment[]
  defectAttachments DefectAttachment[]
  commentAttachments CommentAttachment[]

  @@index([email])
  @@index([roleId])
  @@index([deletedAt])
}

// Password Reset Tokens
model PasswordResetToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique // Random token sent via email
  expiresAt DateTime // Token expiration time (1 hour)
  usedAt    DateTime? // When token was used (null = unused)
  createdAt DateTime @default(now())

  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

// API Keys for programmatic access
model ApiKey {
  id          String   @id @default(cuid())
  userId      String
  projectId   String?  // Optional: if null, key has access to all user's projects
  name        String   // User-friendly name for the key
  keyHash     String   @unique // Hashed API key (bcrypt)
  keyPrefix   String   // First 11 characters of the key for identification (e.g., "ez_abc12345")
  lastUsedAt  DateTime? // Last time the key was used
  expiresAt   DateTime? // Optional expiration date
  isActive    Boolean  @default(true) // Soft delete flag
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  project     Project? @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([projectId])
  @@index([keyHash])
  @@index([keyPrefix])
  @@index([isActive])
  @@index([expiresAt])
}

model OtpVerification {
  id        String   @id @default(cuid())
  email     String   // Email to verify
  otp       String   // 6-digit OTP code
  type      String   // 'login' or 'register'
  expiresAt DateTime // OTP expiration time (10 minutes)
  verified  Boolean  @default(false) // Whether OTP has been verified
  attempts  Int      @default(0) // Number of verification attempts
  createdAt DateTime @default(now())

  @@index([email])
  @@index([otp])
  @@index([expiresAt])
}

// Project Management
model Project {
  id          String   @id @default(cuid())
  name        String
  key         String   @unique  // Short key like "PROJ"
  description String?
  isDeleted   Boolean  @default(false) // Soft delete flag
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdById String

  createdBy   User     @relation("CreatedBy", fields: [createdById], references: [id])
  members     ProjectMember[]
  testSuites  TestSuite[]
  testCases   TestCase[]
  testRuns    TestRun[]
  requirements Requirement[]
  modules     Module[]
  defects     Defect[]
  apiKeys     ApiKey[]

  @@index([key])
  @@index([createdById])
  @@index([isDeleted])
}

model ProjectMember {
  id        String   @id @default(cuid())
  projectId String
  userId    String
  joinedAt  DateTime @default(now())

  project   Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([projectId, userId])
  @@index([projectId])
  @@index([userId])
}

// Test Management
model Module {
  id          String   @id @default(cuid())
  projectId   String
  name        String
  description String?
  order       Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  testCases   TestCase[]

  @@unique([id, projectId]) // Required for composite FK from TestCase
  @@unique([projectId, name])
  @@index([projectId])
}

model TestSuite {
  id          String   @id @default(cuid())
  projectId   String
  name        String
  description String?
  parentId    String?
  order       Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  parent      TestSuite? @relation("NestedSuites", fields: [parentId], references: [id], onDelete: Cascade)
  children    TestSuite[] @relation("NestedSuites")
  testCases   TestCase[] // Legacy: Keep for backward compatibility, will be deprecated
  testCaseSuites TestCaseSuite[] // New many-to-many relation
  testRuns    TestRunSuite[]

  @@index([projectId])
  @@index([parentId])
}

model TestCase {
  id            String   @id @default(cuid())
  tcId          String   // Test case ID like tc1, tc2, etc. (unique per project)
  projectId     String
  moduleId      String?
  suiteId       String?  // Legacy: Keep for backward compatibility, will be deprecated
  title         String
  description   String?
  expectedResult String?  // Overall expected result for the test case
  priority      String   @default("MEDIUM") // Dynamic dropdown value
  status        String   @default("ACTIVE") // Dynamic dropdown value
  estimatedTime Int?     // in minutes
  preconditions String?
  postconditions String?
  testData      String?  // Test data/input values for the test case
  pendingDefectIds String?  // Comma-separated defect IDs that don't exist yet (e.g., "DEF-1, DEF-2")
  // New fields for enhanced test case management
  rtcId         String?  // RTC-ID
  flowId        String?  // Flow-ID
  layer         TestLayer?  // Layer
  testType      String?  // テスト種別（正常系、異常系、非機能、回帰、データ整合性確認、状態遷移確認、運用確認、障害時確認）
  evidence      String?  // 根拠コード
  notes         String?  // 備考
  platform      String?   // プラットフォーム: Web, Web(SP), iOS Native, Android Native（単一選択）
  device        String?   // 端末: iPhone, Android, PC
  domain        String?   // ドメイン
  functionName  String?   @map("function") // 機能（DB予約語のため functionName）
  executionType String?   // 実行方式: 手動 / 自動
  automationStatus String? // 自動化状況: 自動化済 / 自動化対象 / 自動化対象外 / 検討中
  createdById   String
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  project       Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  module        Module?  @relation(fields: [moduleId, projectId], references: [id, projectId], onDelete: Cascade)
  suite         TestSuite? @relation(fields: [suiteId], references: [id], onDelete: Cascade) // Legacy
  createdBy     User     @relation(fields: [createdById], references: [id])
  testCaseSuites TestCaseSuite[] // New many-to-many relation
  steps         TestStep[]
  results       TestResult[]
  requirements  Requirement[]
  comments      Comment[]
  attachments   Attachment[]
  defects       TestCaseDefect[] // Many-to-many relation

  @@unique([projectId, tcId])
  @@index([projectId])
  @@index([moduleId])
  @@index([suiteId])
  @@index([createdById])
  @@index([status])
  @@index([priority])
}

// Join table for many-to-many relationship between TestCase and TestSuite
model TestCaseSuite {
  id          String   @id @default(cuid())
  testCaseId  String
  testSuiteId String
  addedAt     DateTime @default(now())

  testCase    TestCase  @relation(fields: [testCaseId], references: [id], onDelete: Cascade)
  testSuite   TestSuite @relation(fields: [testSuiteId], references: [id], onDelete: Cascade)

  @@unique([testCaseId, testSuiteId])
  @@index([testCaseId])
  @@index([testSuiteId])
}

model TestStep {
  id          String   @id @default(cuid())
  testCaseId  String
  stepNumber  Int
  action      String
  expectedResult String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  testCase    TestCase @relation(fields: [testCaseId], references: [id], onDelete: Cascade)
  attachments Attachment[]

  @@unique([testCaseId, stepNumber])
  @@index([testCaseId])
}

model TestRun {
  id          String   @id @default(cuid())
  projectId   String
  name        String
  description String?
  status      String   @default("PLANNED") // Dynamic dropdown value
  assignedToId String?
  environment String?  // Dynamic dropdown value e.g., "Production", "Staging", "QA"
  startedAt   DateTime?
  completedAt DateTime?
  createdById String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  assignedTo  User?    @relation(fields: [assignedToId], references: [id])
  createdBy   User     @relation("TestRunCreator", fields: [createdById], references: [id])
  results     TestResult[]
  suites      TestRunSuite[]
  defects     Defect[]

  @@index([projectId])
  @@index([assignedToId])
  @@index([createdById])
  @@index([status])
  @@index([environment])
}

model TestRunSuite {
  id          String   @id @default(cuid())
  testRunId   String
  testSuiteId String
  createdAt   DateTime @default(now())

  testRun     TestRun  @relation(fields: [testRunId], references: [id], onDelete: Cascade)
  testSuite   TestSuite @relation(fields: [testSuiteId], references: [id], onDelete: Cascade)

  @@unique([testRunId, testSuiteId])
  @@index([testRunId])
  @@index([testSuiteId])
}

model TestResult {
  id          String   @id @default(cuid())
  testRunId   String
  testCaseId  String
  status      String   // Dynamic dropdown value: PASSED, FAILED, BLOCKED, SKIPPED, RETEST
  executedById String
  duration    Int?     // in seconds
  comment     String?
  errorMessage String?
  stackTrace  String?
  executedAt  DateTime @default(now())

  testRun     TestRun  @relation(fields: [testRunId], references: [id], onDelete: Cascade)
  testCase    TestCase @relation(fields: [testCaseId], references: [id], onDelete: Cascade)
  executedBy  User     @relation(fields: [executedById], references: [id])
  attachments Attachment[]

  @@unique([testRunId, testCaseId])
  @@index([testRunId])
  @@index([testCaseId])
  @@index([executedById])
  @@index([status])
}

// Requirements Management
model Requirement {
  id          String   @id @default(cuid())
  projectId   String
  key         String   // e.g., "REQ-001"
  title       String
  description String?
  priority    String   @default("MEDIUM") // Dynamic dropdown value
  status      String   @default("DRAFT") // Dynamic dropdown value
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  project     Project  @relation(fields: [projectId], references: [id], onDelete: Cascade)
  testCases   TestCase[]

  @@unique([projectId, key])
  @@index([projectId])
  @@index([status])
  @@index([priority])
}

// Supporting Models
model Comment {
  id          String   @id @default(cuid())
  testCaseId  String
  userId      String
  content     String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  testCase    TestCase @relation(fields: [testCaseId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([testCaseId])
  @@index([userId])
}

model Attachment {
  id            String   @id @default(cuid())
  filename      String
  originalName  String
  mimeType      String
  size          Int
  path          String
  fieldName     String?  // description, expectedResult, preconditions, postconditions, action
  testCaseId    String?
  testStepId    String?
  testResultId  String?
  uploadedAt    DateTime @default(now())

  testCase      TestCase?   @relation(fields: [testCaseId], references: [id], onDelete: Cascade)
  testStep      TestStep?   @relation(fields: [testStepId], references: [id], onDelete: Cascade)
  testResult    TestResult? @relation(fields: [testResultId], references: [id], onDelete: Cascade)

  @@index([testCaseId])
  @@index([testStepId])
  @@index([testResultId])
}

// ====================================
// RBAC (Role-Based Access Control)
// ====================================

model Role {
  id          String         @id @default(cuid())
  name        String         @unique // e.g., "ADMIN", "PROJECT_MANAGER", "TESTER", "VIEWER"
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  users       User[]
  permissions RolePermission[]

  @@index([name])
}

model Permission {
  id          String         @id @default(cuid())
  name        String         @unique // e.g., "projects:read", "projects:create", "testcases:update"
  description String?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  roles       RolePermission[]

  @@index([name])
}

model RolePermission {
  id           String     @id @default(cuid())
  roleId       String
  permissionId String
  createdAt    DateTime   @default(now())

  role         Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission   Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)

  @@unique([roleId, permissionId])
  @@index([roleId])
  @@index([permissionId])
}

// ====================================
// Dropdown Options Management
// ====================================

model DropdownOption {
  id          String   @id @default(cuid())
  entity      String   // e.g., "TestCase", "Defect", "TestRun", "Requirement"
  field       String   // e.g., "priority", "status", "severity"
  value       String   // The actual value stored in database (e.g., "CRITICAL", "HIGH")
  label       String   // The display label for users (e.g., "Critical", "High Priority")
  order       Int      @default(0) // For sorting options
  isActive    Boolean  @default(true) // Soft delete flag
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([entity, field, value])
  @@index([entity, field])
  @@index([isActive])
}

// ====================================
// Defect Management
// ====================================

model Defect {
  id            String        @id @default(cuid())
  defectId      String        // Defect ID like DEF-001, DEF-002, etc. (unique per project)
  projectId     String
  title         String
  description   String?       @db.Text
  severity      String        @default("MEDIUM") // Dynamic dropdown value
  priority      String        @default("MEDIUM") // Dynamic dropdown value
  status        String        @default("NEW") // Dynamic dropdown value
  assignedToId  String?
  testRunId     String?       // Optional link to test run
  environment   String?       // Dynamic dropdown value e.g., "Production", "Staging", "QA"
  dueDate       DateTime?     // Optional due date for the defect
  progressPercentage Int?      // Optional progress percentage (0-100)
  createdById   String
  resolvedAt    DateTime?
  closedAt      DateTime?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  project       Project       @relation(fields: [projectId], references: [id], onDelete: Cascade)
  assignedTo    User?         @relation("DefectAssignedTo", fields: [assignedToId], references: [id])
  createdBy     User          @relation("DefectCreatedBy", fields: [createdById], references: [id])
  testRun       TestRun?      @relation(fields: [testRunId], references: [id])
  testCases     TestCaseDefect[] // Many-to-many relation
  attachments   DefectAttachment[]
  comments      DefectComment[]

  @@unique([projectId, defectId])
  @@index([projectId])
  @@index([assignedToId])
  @@index([createdById])
  @@index([testRunId])
  @@index([status])
  @@index([severity])
  @@index([priority])
  @@index([environment])
}

model DefectAttachment {
  id            String   @id @default(cuid())
  defectId      String
  filename      String
  originalName  String
  mimeType      String
  size          Int
  path          String
  fieldName     String?  // description, environment, etc.
  uploadedById  String
  uploadedAt    DateTime @default(now())

  defect        Defect     @relation(fields: [defectId], references: [id], onDelete: Cascade)
  uploadedBy    User       @relation(fields: [uploadedById], references: [id], onDelete: Cascade)

  @@index([defectId])
  @@index([uploadedById])
}

model DefectComment {
  id            String   @id @default(cuid())
  defectId      String
  userId        String
  content       String   @db.Text
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  defect        Defect   @relation(fields: [defectId], references: [id], onDelete: Cascade)
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  attachments   CommentAttachment[]

  @@index([defectId])
  @@index([userId])
}

model CommentAttachment {
  id             String         @id @default(cuid())
  commentId      String
  filename       String
  originalName   String
  mimeType       String
  size           Int
  path           String
  fieldName      String?
  uploadedById   String
  uploadedAt     DateTime       @default(now())

  comment        DefectComment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  uploadedBy     User           @relation(fields: [uploadedById], references: [id], onDelete: Cascade)

  @@index([commentId])
  @@index([uploadedById])
}

// Join table for many-to-many relationship between TestCase and Defect
model TestCaseDefect {
  id          String   @id @default(cuid())
  testCaseId  String
  defectId    String
  linkedAt    DateTime @default(now())

  testCase    TestCase @relation(fields: [testCaseId], references: [id], onDelete: Cascade)
  defect      Defect   @relation(fields: [defectId], references: [id], onDelete: Cascade)

  @@unique([testCaseId, defectId])
  @@index([testCaseId])
  @@index([defectId])
}
